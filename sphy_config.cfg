# The Spatial Processes in HYdrology (SPHY) model:
# A spatially distributed hydrological model 
# Copyright (C) 2013-2019  FutureWater
# Email: sphy@futurewater.nl
#
# Authors (alphabetical order):
# P. Droogers, J. Eekhout, W. Immerzeel, S. Khanal, A. Lutz, G. Simons, W. Terink
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#***********************************************************************************************
# CONFIGURATION FILE BELONGING TO SPHY. MODEL CHANGES CAN BE DONE IN THIS FILE. THIS FILE
# CAN BE USED TO CHANGE MODEL INPUT, SET PARAMETERS, MODEL OUTPUT, AND TURN ON/OFF MODULES
#
# THE SPATIAL PROCESSES IN HYDROLOGY (SPHY) MODEL IS DEVELOPED AND OWNED BY FUTUREWATER.
#***********************************************************************************************

#***********************************************************************************************
# SPHY enables the user to turn/off certain modules. The flags below can be used to turn on/off
# these modules (1=on, 0=off)
#***********************************************************************************************
[MODULES]

# Glacier melt processes module. This automatically turns on the snow module as well.
GlacFLAG	= 0
# Snow module. If the glacier melt processes module is turned on, then this is also turned on
# automatically. If the glacier melt processes module is turned off, then you may turn this on
# if you want to incorporate snow melt and accumulation.
SnowFLAG	= 1
# Routing module. If streamflow routing should be included, then this should be turned on. If
# this is turned on, then the reservoir module should be switched off.
RoutFLAG	= 1
# Lakes module. If lakes are located in your basin, and the Q(h)-relations are known,
# then this can be turned on to implement a more advanced routing scheme. If this module is
# turned on, then the routing module should be switched off.
LakeFLAG    = 0
# Reservoirs module. This module can be used to model reservoir inflow, outflow, and storage. A
# simple or advanced reservoir operation schedule can be selected for each individual reservoir.
# If this module is turned on, then the routing module should be switched off.
ResFLAG		= 0
# Dynamic vegetation module. This module allows to vary the crop factor (Kc) over the year. This
# can be done by using ndvi values, or by inserting a user defined kc time-series. If this
# module is not used, then the Kc will be constant for each crop.
DynVegFLAG	= 1
# Groundwater module. This distincs between the use of a groundwater reservoir or the use of a
# seepage flux (bottom boundary condition). If the groundwater module is chosen, then percolation
# will occur from the second to third (groundwater) storage, finally resulting in a baseflow flux.
# Otherwise a seepage flux leaves or enters the second storage volume, which eventually results
# in a sub drainage flux.
GroundFLAG	= 1
# Sediment module. Calculates sediment yield according to any of the 6 soil erosion models.
SedFLAG     = 1
# Sediment transport module. Flag to indicate sediment will be routed through
# the channel network. Sediment transport is not simulated if the lake or reservoir modules are used.
SedTransFLAG = 0

#***********************************************************************************************
# Define the input and output directories (with /) with respect to the working dir
# (= dir where *.py is located)
#***********************************************************************************************
[DIRS]

inputdir 		= /
outputdir 		= /

#***********************************************************************************************
# Define the start and end of your model simulation period (all values should be defined as
# integers)
#***********************************************************************************************
[TIMING]

startyear       = 
startmonth      = 
startday        = 
endyear         = 
endmonth        = 
endday          = 

# SET NUMBER OF SPIN-UP YEARS
spinupyears = 1

#***********************************************************************************************
# Define general input maps
#***********************************************************************************************
[GENERAL]

# CLONE MAP (boolean map with TRUE for model domain)
mask			= clone_boolean.map
# DEM (Digital Elevation Model)
dem				= dem.map
# SLOPE (scalar map with the slope (-))
Slope			= slope.map
# LOCATIONS MAP (nominal map with IDs of locations where time-series will be recorded, e.g. streamflow locations)
locations	= stations_reporting_nominal.map

#***********************************************************************************************
# Define soil input maps
#***********************************************************************************************
[SOIL]

# FIELD CAPACITY ROOTZONE (scalar map with the field capacity of the rootzone (mm/mm))
RootFieldMap 	=
# SATURATED WATER CONTENT ROOTZONE (scalar map with the saturated water content of the rootzone (mm/mm))
RootSatMap		=
# PERMANENT WILTING POINT ROOTZONE (scalar map with permanent wilting point rootzone (mm/mm))
RootDryMap 		=
# WILTING POINT ROOTZONE (scalar map with wilting point of rootzone (mm/mm))
RootWiltMap 	=
# SATURATED HYDRAULIC CONDUCTIVITY ROOTZONE (scalar map with saturated hydraulic conductivity rootzone (mm/day))
RootKsat 		=
# FIELD CAPACITY SUBSOIL (scalar map with field capacity of the subsoil (mm/mm))
SubFieldMap 	=
# SATURATED WATER CONTENT SUBSOIL (scalar map with saturated water content of subsoil (mm/mm))
SubSatMap		=
# SATURATED HYDRAULIC CONDUCTIVITY SUBSOIL (scalar map with saturated hydraulic conductivity subsoil (mm/day))
SubKsat 		=


[PEDOTRANSFER]

# Pedotransfer FLAG. Flag to indicate if soil hydraulic properties are determined based on a
# pedotransfer function. The pedotransfer functions need sand, clay, organic matter and bulk density
# factor maps as input.
PedotransferFLAG 	= 1
# SAND ROOTZONE (scalar map with the percentage sand in the rootzone (%))
RootSandMap 	= soil/root_sand.map
# CLAY ROOTZONE (scalar map with the percentage clay in the rootzone (%))
RootClayMap 	= soil/root_clay.map
# ORGANIC MATTER ROOTZONE (scalar map with the percentage organic matter in the rootzone (%))
RootOMMap 	= soil/root_OM.map
# BULK DENSITY ROOTZONE (scalar map with the bulk density factor in the rootzone (-)). When this map is not available,
# unity (=1) is assumed.
RootBulkMap 	= 1
# SAND SUBSOIL (scalar map with the percentage sand in the subsoil (%))
SubSandMap 	= soil/subsoil_sand.map
# CLAY SUBSOIL (scalar map with the percentage clay in the subsoil (%))
SubClayMap 	= soil/subsoil_clay.map
# ORGANIC MATTER SUBSOIL (scalar map with the percentage organic matter in the subsoil (%))
SubOMMap 	= soil/subsoil_OM.map
# BULK DENSITY SUBSOIL (scalar map with the bulk density factor in the subsoil (-)). Can be map or single value.
SubBulkMap 	= 1



[SOIL_INIT]

# INITIAL ROOTWATER CONTENT (initial rootwater content (mm), if no value is supplied, 
# then RootWater=field capacity rootzone). Can be map or single value.
RootWater		=
# INITIAL SUBSOIL WATER CONTENT (initial water content in subsoil (mm), if no value is supplied,
# then SubWater=field capacity subsoil). Can be map or single value.
SubWater		= 10
# INITIAL CAPILLARY RISE (initial capillary rise (mm). Can be map or single value.
CapRise 		= 0
# INITIAL DRAINAGE ROOTZONE (initial drainage from rootzone (mm)). Can be map or single value.
RootDrain 		= 0
# INITIAL DRAINAGE SUBSOIL (initial drainage from the subsoil (mm)). Can be map or single value.
# This can be left empty if the groundwater module is used, because then recharge to the gw will
# be calculated instead.
SubDrain		= 0

[SOIL_CAL]
# FIELD CAPACITY ROOTZONE (scalar map with the field capacity of the rootzone (mm/mm))
RootFieldFrac 	= 1
# SATURATED WATER CONTENT ROOTZONE (scalar map with the saturated water content of the rootzone (mm/mm))
RootSatFrac		=  1
# PERMANENT WILTING POINT ROOTZONE (scalar map with permanent wilting point rootzone (mm/mm))
RootDryFrac		= 1
# WILTING POINT ROOTZONE (scalar map with wilting point of rootzone (mm/mm))
RootWiltFrac 	=   1
# SATURATED HYDRAULIC CONDUCTIVITY ROOTZONE (scalar map with saturated hydraulic conductivity rootzone (mm/day))
RootKsatFrac	=   1


#***********************************************************************************************
# Define soil parameters
#***********************************************************************************************
[SOILPARS]

# ROOTZONE DEPTH (thickness of rootzone (mm)). Can be map or single value.
RootDepthFlat 	= 300
# SUBSOIL DEPTH (thickness of subsoil (mm)). Can be map or single value.
SubDepthFlat 	= 150
# MAXIMUM ALLOWED CAPILLARY RISE (maximum capillary rise from subsoil to rootzone (mm/day)). Can be map
# or single value.
CapRiseMax 		= 0.25
# SEEPSTATIC. Flag that determines the use of a constant seepage value throughout the entire simulation
# period, or the use of a dynamic seepage map series. Use 1 for static, and 0 for dynamic. If dynamic
# groundwater module is used, then this can be left empty.
SeepStatic		=
# SEEPAGE (mm/d) (pos=downwards=outgoing). If groundwater module is used, then this can be left
# empty. Can be map or single value. If SeepStatic flag = 0, then a map time-series should be filled in.
SeePage			=
# GWL_BASE. Average groundwater level through the year. Can be taken as the average of the highest
# and lowest measured groundwater level. Value should be negative (=depth in m below surface), and can be a map or
# a single value. If groundwater module is used, then this can be left empty.
GWL_base		=

[INFILTRATION]
# INFILTRATION EXCESS. Flag to include infiltration excess runoff.
Infil_excess = 1
# ALPHA. Fraction [-] of daily rainfall that occurs during the hour of the most intense rainfall. Can be
# a map or a single value.
Alpha = 0.32
# LABDA INFILTRATION COEFFICIENT. Affects the speed in which the infiltration capacity
# reduces due to actual rootwater content and the saturated hydraulic conductivity. Can be a spatial
# map or a single value. Higher values correspond with a faster reduction in infiltration capacity.
Labda_infil = 1.65
# EFFECTIVE SATURATED HYDRAULIC CONDUCTIVITY. Factor for calculation of the effective hydraulic conductivity.
K_eff = 0.5
# PAVED SURFACE. Fraction of paved surface per land use class. Format should be # as shown below, with ID 
# corresponding to landuse IDs. The first line should not be in the table file and the # marks should be removed:
# ID    # paved fraction
# -99   1
# 1     value1
PavedFrac	    = paved.tbl

#***********************************************************************************************
# Define soil parameters for groundwater module. Can be left empty if groundwater module is not
# used
#***********************************************************************************************
[GROUNDW_PARS]

# GROUNDWATER DEPTH (thickness of groundwater layer (mm)). Can be a map or single value.
GwDepth			= 2000
# SATURATED WATER CONTENT GROUNDWATER (saturated water content in groundwater zone (mm)). Can be
# map or single value.
GwSat 			= 200
# GROUNDWATER RECHARGE DELAY TIME (delay in groundwater recharge (days)). Can be map or single value.
deltaGw 		= 300
# BASEFLOW THRESHOLD (minimum value for baseflow to occur (mm)). Can be map or single value.
BaseThresh 		= 0
# BASEFLOW DAYS (parameter of baseflow days: alfaGw = 2.3/X (X = nr. of baseflow days).
# AlfaGw ranges between 0.1-1.0). Can be map or single value.
alphaGw 		= 0.5
# SPECIFIC AQUIFER YIELD (m/m). This is the specific yield of the groundwater storage and is used for
# the groundwater table height calculation.
YieldGw			= 0.05

[GROUNDW_INIT]

# INITIAL GROUNDWATER RECHARGE (initial groundwater recharge (mm)). Can be map or single value.
GwRecharge 		= 0
# INITIAL BASEFLOW (initial baseflow (mm)). Can be map or single value.
BaseR 			= 0
# INITIAL GROUNDWATER STORAGE (initial groundwater storage (mm)). Can be map or single value.
Gw 				= 100
# INITIAL GROUNDWATER TABLE HEIGHT (positive value (m)). This is the groundwater table in m below surface.
# This value should be higher than the total depth of the root and subzone depths, and smaller or equal
# to the total depth of the three soil layers (root+sub+gw). Can be map or single value.
H_gw			= 3

#***********************************************************************************************
# Define landuse/crop data. The DYNVEC module has only be filled in if the dynamic vegetation
# module is turned on.
#***********************************************************************************************
[LANDUSE]

# LANDUSE MAP (nominal map with landuse IDs).
LandUse         = landuse.map
# KCSTATIC. Flag that determines the use of a constant kc throughout the entire simulation period,
# or the use of a dynamic kc map series. Use 1 for static, and 0 for dynamic. If dynamic vegetation
# module is used, then this can be left empty.
KCstatic 		= 0
# CROP COEFFICIENTS (lookup table with crop coefficient (-) for each landuse ID). If the dynamic
# vegetation module is used or the kcstatic value=0, then this lookup table is not required and can
# thus be left empty.
CropFac			= 
# CROP COEFFICIENTS MAP SERIES. This one is only used if KCstatic=0 and the dynamic vegetation module
# is not used. Otherwise it can be left empty.
KC				=


[DYNVEG]

# NDVI. Map series (define without *.map extension) with ndvi.
NDVI		    = ndvi/ndvi

# NDVI Max. The maximum ndvi value. Can be a map or single value.
NDVImax		= 0.65
# NDVI Min. The minimum ndvi value. Can be a map or single value.
NDVImin		= 0.1
# NDVI Base. A base value for the ndvi. This value will be used if there is missing data in the ndvi
# image. Can be a map or single value.
NDVIbase	= 0.15
# Kc max. The maximum crop factor. Can be a map or single value.
KCmax		= 1.5
# Kc min. The maximum crop factor. Can be a map or single value.
KCmin		= 0.5
# LAI max. The maximum LAI value. Format should be # as shown below, with ID corresponding to
# landuse IDs. The first line should not be in the table file and the # marks should be removed:
# ID    # LAI max
# -99   1
# 1     value1
LAImax		= LAImax.tbl
# FPAR max. The maximum fPAR (Fraction of Absorbed Photosynthetically Active Radiation) value. Can
# be a map or single value.
FPARmax		= 0.95
# FPAR min. The minimum fPAR (Fraction of Absorbed Photosynthetically Active Radiation) value. Can
# be a map or single value.
FPARmin		= 0.001


[PWS]

# PWS FLAG. If the actual ET is determined using the plant-specific depletion factor, then this
# flag can be turned on (1=Y, 0=N). If this is not used, then the actual ET will be calculated using
# the wilting point in the rootzone.
PWS_FLAG		= 1
# DEPLETION FRACTION LOOKUP TABLE. Average fraction of Total Available Soil Water (TAW) that can be
# depleted from the root zone before moisture stress (reduction in ET) occurs [0-1]. Format should be
# as shown below, with ID corresponding to landuse IDs. The first line should not be in the table file
# and the # marks should be removed:
# ID    # depletion fraction
# -99   1
# 1     value1
PFactor     = depletion.tbl


[OPENWATER]

# ET OPEN WATER FLAG. Flag to indicate if ET should be calculated from the area of the reservoirs.
ETOpenWaterFLAG = 0
# KC OPEN WATER. The crop coefficient for the calculation of potential evapotranspiration in open water.
kcOpenWater = 1.2
# OPENWATER FRACTION MAP. Scalar map with a fraction of cell that is classified as openwater.
openWaterFrac = openwater_frac.map

#***********************************************************************************************
# Define glacier parameters if glacier module is used. Can be left empty if glacier module is
# not used.
#***********************************************************************************************
[GLACIER]

# GLACIER CSV TABLE. This table contains a unique cell id and is based on a uniqe combination of the 
# model grid id and glacier id. Table colums should be: "U_ID, MOD_ID, GLAC_ID, MOD_H, GLAC_H, 
# DEBRIS (1=Yes, 0= Clean Ice), FRAC_GLAC".   
GlacTable       = 
# MODEL ID. Nominal map with a unique ID for each model grid cell.
ModelID         = 
# GLACIER ID. Nominal map with a unique ID for each glacier.
GlacID          =  
# GLACIER (clean ice) DEGREE DAY FACTOR (degree day factor for glacier (mm degree-1 day-1).
# Can be map or single value.
DDFG            = 4
# GLACIER DEBRIS DEGREE DAY FACTOR (degree day factor for glacier (mm degree-1 day-1).
# Can be map or single value.
DDFDG           = 2
# GLACIER MELT FRAC RUNOFF (fraction of glacier melt to become runoff (-)).
# Can be map or single value.
GlacF           = 0.548
#-Flag to report flux per glacier id (1=Yes, 0=No)
GlacID_flag     = 1
#-Glacier fluxes to report per glacier ID (select from comma separated list: 'Prec_GLAC', 'Rain_GLAC', 'Snow_GLAC', 'ActSnowMelt_GLAC', 'SnowStore_GLAC', 'SnowWatStore_GLAC',  'TotalSnowStore_GLAC', 'SnowR_GLAC', 'GlacMelt', 'GlacR', 'GlacPerc')
GlacVars        = FRAC_GLAC,ICE_DEPTH,GLAC_T,Prec_GLAC,Rain_GLAC,Snow_GLAC,ActSnowMelt_GLAC,SnowStore_GLAC,SnowWatStore_GLAC,TotalSnowStore_GLAC,SnowR_GLAC,GlacMelt,GlacR,GlacPerc
# GLACIER RETREAT FLAG (Flag to implement dynamic retreat of glacier, Y=1, N=0). This allows for disappearance
# of glacier fraction if completely melted. If this is used, then last column of GlacTable should contain field "ICE_DEPTH"
GlacRetreat     = 1
#-Mem Error: with many glaciers, long time-series, and many fluxes to report, a memory error may occur. If that's the case, then set GlacID_memerror = 1
GlacID_memerror = 1
# GLACFRAC UPDATE DATE. Day and month in year (d,m, e.g. 30,9 (30 september)) when the glacier fraction should be updated. Is only required when
# glacier retreat flag equals 1.
GlacUpdate      = 30,9
# TLAPSE (table with lapse rates per month to lapse model grid cel temperature to glacier elevation temperature (degrees Celsius/m elevation increase))
TLapse          = 

#***********************************************************************************************
# Define snow parameters if snow module is used. This has to be filled in if the glacier
# module is used. If both snow and glacier module are not used, then this can be left empty.
#***********************************************************************************************
[SNOW]

# CRITICAL SNOW TEMPERATURE (critical temperature for precipitation to fall as snow (degrees Celsius)).
# Can be map or single value.
TCrit 			= 1.2
# SNOW PACK CAPACITY (storage capacity of snow pack (mm/mm)).
# Can be map or single value.
SnowSC			= 0.5
# SNOW DEGREE DAY FACTOR (mm degree-1 day-1). Can be map or single value.
DDFS			= 5

[SNOW_INIT]

# INITIAL SNOW STORAGE (scalar map with initial snow storage (mm)). Can be map or single value.
SnowIni			= 0
# WATER STORAGE SNOWPACK (initial water stored in snow pack (mm)). Can be map or single value.
SnowWatStore 	= 0

#***********************************************************************************************
# Define climate forcing data for model input.
#***********************************************************************************************
[CLIMATE]

# PREC (map series (define without *.map extension) with precipitation (mm))
Prec         	= 
# PREC NETCDF FLAG. Flag to indicate to use netcdf for precipitation forcing 
precNetcdfFLAG  = 0
# PREC NETCDF. Location of the netcdf file
precNetcdf      = 
# PREC NETCDF INPUT. Input parameters for the netcdf file. Seven parameters need to be provided: variable from the netcdf,
# variable defining the x-coordinates, variable defining the y-coordinates, interpolation method (linear, cubic or nearest), factor 
# for multiplying the precipitation to mm, epsg code of netcdf (use 'rotated' for rotated pole coordinates), epsg code of model domain
precNetcdfInput = pcp,X,Y,linear,0.1,epsg:25830,epsg:25830

# TAIR (map series (define without *.map extension) with air temperature (degrees Celsius)). Only needed
# if glacier or snow module is used, or if ETREF_FLAG is set to 0 (see section below).
Tair         	= 
# TEMP NETCDF FLAG. Flag to indicate to use netcdf for temperature forcing 
tempNetcdfFLAG  = 0
# TEMP NETCDF. Location of the netcdf file
# tempNetcdf = 
tempNetcdf      = 
# TEMP NETCDF INPUT. Input parameters for the netcdf file. Input parameters for the netcdf file. Seven parameters need to be provided: variable from the netcdf,
# variable defining the x-coordinates, variable defining the y-coordinates, interpolation method (linear, cubic or nearest), factor 
# for multiplying the temperature to degrees Celcius, epsg code of netcdf (use 'rotated' for rotated pole coordinates), epsg code of model domain
tempNetcdfInput = tas,rlon,rlat,cubic,1,rotated,epsg:25830

[ETREF]

# ETREF FLAG. If a map time-series exists of the reference evapotranspiration (etref), then this
# flag can be turned on (1=Y, 0=N). If this is not used, then the etref will be calculated using
# Hargreaves.
ETREF_FLAG		= 0
# ETREF (map series (define without *.map extension) with etref (mm)). Only define if ETREF_FLAG
# = 1. Otherwise can be left empty.
ETref			= forcing/etref
# LATITUDE ZONES (map with latitude zones required for calculation of extraterrestrial radiation).
# Only define if ETREF_FLAG = 0. Otherwise can be left empty.
Lat           	= latitude.map
# SOLAR CONSTANT (MJ/m2/min). Put single float value.
Gsc 			= 0.0820

# TMIN (map series (define without *.map extension) with minimum air temperature (degrees Celsius).
# Only define if ETREF_FLAG = 0. Otherwise can be left empty.
Tmin         	= 
# TMIN NETCDF FLAG. Flag to indicate to use netcdf for minimum air temperature forcing 
TminNetcdfFLAG  = 0
# TMIN NETCDF. Location of the netcdf file
TminNetcdf      = 
# TMIN NETCDF INPUT. Input parameters for the netcdf file. Seven parameters need to be provided: variable from the netcdf,
# variable defining the x-coordinates, variable defining the y-coordinates, interpolation method (linear, cubic or nearest), factor 
# for multiplying the temperature to degrees Celcius, epsg code of netcdf (use 'rotated' for rotated pole coordinates), epsg code of model domain
TminNetcdfInput = tasmin,rlon,rlat,cubic,1,rotated,epsg:25830

# TMAX (map series (define without *.map extension) with maximum air temperature (degrees Celsius).
# Only define if ETREF_FLAG = 0. Otherwise can be left empty.
Tmax         	= 
# TMAX NETCDF FLAG. Flag to indicate to use netcdf for maximum air temperature forcing 
TmaxNetcdfFLAG  = 0
# TMAX NETCDF. Location of the netcdf file
TmaxNetcdf      = tasmax.nc
# TMAX NETCDF INPUT. Input parameters for the netcdf file. Seven parameters need to be provided: variable from the netcdf,
# variable defining the x-coordinates, variable defining the y-coordinates, interpolation method (linear, cubic or nearest), factor 
# for multiplying the temperature to degrees Celcius, epsg code of netcdf (use 'rotated' for rotated pole coordinates), epsg code of model domain
TmaxNetcdfInput = tasmax,rlon,rlat,cubic,1,rotated,epsg:25830


#***********************************************************************************************
# Define routing maps and parameters. This has to be filled in if the routing, lake or reservoir
# module is used.
#***********************************************************************************************
[ROUTING]

# FLOWDIR MAP (local drainage direction based on DEM)
flowdir			= ldd.map
# RECESSION ROUTING COEF (recession coefficient of routing (-)). Can be map or single value.
kx				= 0.765
# ROUTING INDIVIDUAL FLOW COMPONENTS. Flag (1=Y, 0=N) that determines if individual flow components
# should be routed.
Rout_components = 0

#***********************************************************************************************
# Define initial routed runoff. This has only to be filled in if the simple routing module is used
# and the lake and reservoir modules are both not used.
#***********************************************************************************************
[ROUT_INIT]

# INITIAL ROUTED TOTAL RUNOFF (m3/s). Can be a map or a single value.
QRA_init		= 0
# FLAG FOR INITIAL ROUTED ROOT SURFACE RUNOFF (m3/s). Can be a map or a single value. If left empty,
# then the routed rainfall rainfall runoff will not be calculated.
RootRRA_init		= 
# FLAG FOR INITIAL ROUTED ROOT DRAINAGE RUNOFF (m3/s). Can be a map or a single value. If left empty,
# then the routed rainfall rainfall runoff will not be calculated.
RootDRA_init		= 
# FLAG FOR INITIAL ROUTED RAIN RUNOFF (m3/s). Can be a map or a single value. If left empty,
# then the routed rainfall rainfall runoff will not be calculated.
RainRA_init		= 
# FLAG FOR INITIAL ROUTED BASEFLOW RUNOFF (m3/s). Can be a map or a single value. If left empty,
# then the routed rainfall rainfall runoff will not be calculated.
BaseRA_init		= 
# FLAG FOR INITIAL ROUTED SNOW RUNOFF (m3/s). Can be a map or a single value. If left empty,
# then the routed rainfall rainfall runoff will not be calculated.
SnowRA_init		= 
# FLAG FOR INITIAL ROUTED GLACIER RUNOFF (m3/s). Can be a map or a single value. If left empty,
# then the routed rainfall rainfall runoff will not be calculated.
GlacRA_init		= 

#***********************************************************************************************
# Define initial storage maps for lakes and/or reservoirs. This has only be to be filled in if
# the lake and/or reservoir modules are used
#***********************************************************************************************
[STOR_INIT]

# INITIAL TOTAL STORAGE [M3]. Can be a map or single value. If left empty, then the initial
# storage as provided in the tables (under LAKE and RESERVOIR) will be used instead.
Stor_init =
# INITIAL STORAGE FROM SURFACE RUNOFF [M3]. Can be a map or single value. If left empty,
# then the initial storage as provided in the tables (under LAKE and RESERVOIR) will be used instead.
RootRRA_init =
# INITIAL STORAGE FROM ROOT DRAINAGE RUNOFF [M3]. Can be a map or single value. If left empty,
# then the initial storage as provided in the tables (under LAKE and RESERVOIR) will be used instead.
RootDRA_init =
# INITIAL STORAGE FROM RAINFALL RUNOFF [M3]. Can be a map or single value. If left empty,
# then the initial storage as provided in the tables (under LAKE and RESERVOIR) will be used instead.
RainRA_init =
# INITIAL STORAGE FROM SNOW RUNOFF [M3]. Can be a map or single value. If left empty,
# then the initial storage as provided in the tables (under LAKE and RESERVOIR) will be used instead.
SnowRA_init =
# INITIAL STORAGE FROM GLACIER RUNOFF [M3]. Can be a map or single value. If left empty,
# then the initial storage as provided in the tables (under LAKE and RESERVOIR) will be used instead.
GlacRA_init =
# INITIAL STORAGE FROM BASEFLOW RUNOFF [M3]. Can be a map or single value. If left empty,
# then the initial storage as provided in the tables (under LAKE and RESERVOIR) will be used instead.
BaseRA_init =

#***********************************************************************************************
# Define lake maps and parameters. The LAKE module only has to be filled in if
# this module is used. Otherwise it can be left empty.
#***********************************************************************************************
[LAKE]

# LAKE ID MAP. Nominal map with a unique id number specifying each lake in the basin. Zero values for
# non-lake cells
LakeId	= lakeid.map

# USE MEASURED LAKE LEVELS TO CALCULATE THE OUTFLOW (boolean map with true for lakes that have
# measured lake levels, and false for lakes that don't have lake level measurementss). For the
# latter the level will be calculated given the h(S)-relation.
updatelakelevel	= updatelakelevel.map

# LAKE WATER LEVEL FILES (time-series (without *.001 extension) of measured lake levels (m)).
# Should only contain values for lake locations were lake levels are measured. False (mv) for other locations.
LakeFile		= forcing/level

# LAKE STORAGE LOOKUP TABLE. Create a table file containing initial storage volumes (Mm3) for each
# lake that can be found in the LakeId map. Format should be as shown below. The first line should
# not be in the table file and the # marks should be removed:
# ID    #Stor_init [Mm3]   #RainRA_init [Mm3]   #SnowRA_init [Mm3]   #GlacRA_init [Mm3]   #BaseRA_init [Mm3]
# -99   1                 2                     3                     4                     5
# 1     value1            value2                etc                   etc                   etc
LakeStor = lake_id.tbl

# LAKE FUNCTIONS LOOKUP TABLE. Create a table file with for each lake a function that should be
# used for the Q(h)-, S(h)-, and h(S)-relation. Format should be as shown below. The first line should
# not be in the table file and the # marks should be removed:
# ID    #qh_func (1=exp, 2=1_order poly, 3=2_order poly,4=3_order poly)   #sh_func   #hs_func
# -99   1                                                                 2          3
# 1     value1                                                            value2     etc
LakeFunc = lake_function.tbl

# QH-PARAMETERS LOOKUP TABLE. Create a table file with for each lake the parameters for the Q(h)-relation,
# depending on the function that should be used (as determined above). Use missing values (1e31) if the
# parameter is inappropriate for the function to be used. Format should be as shown below. The first line
# should not be in the table file and the # marks should be removed:
# ID   #exp_a   #exp_b   #pol_b   #pol_a1   #pol_a2   #pol_a3
# -99  1        2        3        4         5         6
# 1    value1   value2   1e31     1e31      1e31      1e31
LakeQH = lake_qh.tbl

# SH-PARAMETERS LOOKUP TABLE. Create a table file with for each lake the parameters for the S(h)-relation,
# depending on the function that should be used (as determined above). Use missing values (1e31) if the
# parameter is inappropriate for the function to be used. Format should be as shown below. The first line
# should not be in the table file and the # marks should be removed:
# ID   #exp_a   #exp_b   #pol_b   #pol_a1   #pol_a2   #pol_a3
# -99  1        2        3        4         5         6
# 1    1e31     1e31     value1   value2    1e31      1e31
LakeSH = lake_sh.tbl

# HS-PARAMETERS LOOKUP TABLE. Create a table file with for each lake the parameters for the h(S)-relation,
# depending on the function that should be used (as determined above). Use missing values (1e31) if the
# parameter is inappropriate for the function to be used. Format should be as shown below. The first line
# should not be in the table file and the # marks should be removed:
# ID   #exp_a   #exp_b   #pol_b   #pol_a1   #pol_a2   #pol_a3
# -99   1        2        3        4         5         6
# 1     1e31     1e31     value1   value2    value3    1e31
LakeHS = lake_hs.tbl

#***********************************************************************************************
# Define reservoir maps and parameters. The RESERVOIR module only has to be filled in if
# this module is used. Otherwise it can be left empty.
#***********************************************************************************************

[RESERVOIR]

# RESERVOIR ID MAP. Nominal map with a unique id number specifying each reservoir in the basin. Zero values
# for non-reservoir cells
ResId	= stations_nominal.map

# RESERVOIR FUNCTION AND STORAGE LOOKUP TABLE. Create a table file containing the reservoir function to be
# used (simple or advanced) and the initial storage volumes (Mm3) for each resservoir that can be found in
# the ResId map. Format should be as shown below. The first line should not be in the table file and
# the # marks should be removed:
# ID   #Simple or advanced [1,2]   #Stor_init [Mm3]  #RainRA_init [Mm3]    #SnowRA_init [Mm3]    #GlacRA_init [Mm3]    #BaseRA_init [Mm3]
# -99  1                           2                 3                     4                     5                     6
# 1    1                           value1            value2                etc                   etc                   etc
# 6    2                           etc               etc                   etc                   etc                   etc
ResFuncStor = res_id.tbl

# SIMPLE RESERVOIR PARAMETERS. Create a lookup table file containing the parameters to be used for the
# reservoirs that should be modeled as simple reservoir (Hanasaki et al (2006), which are defined in
# the table shown above. Format should be as shown below. The first line should not be in the table file and
# the # marks should be removed:
# ID   #Kr     #b      #Smax [Mm3]
# -99  1       2       3
# 1    value1  value2  value3
# etc  etc     etc     etc
ResSimple = simple_reservoir.tbl

# ADVANCED RESERVOIR PARAMETERS. Create a lookup table file containing the parameters to be used for the
# reservoirs that should be modeled as advanced reservoirs, using a target release, which are defined in
# the table shown above. Format should be as shown below. The first line should not be in the table file and
# the # marks should be removed:
# ID   #RES_EVOL [Mm3]   #RES_PVOL [Mm3]   #MAX_FLOW [Mm3/d]   #DEM_FLOW [Mm3/d]   #FLOOD_start [d]   #FLOOD_end [d]
# -99  1                 2                 3                   4                   5                  6
# 6    value1            value2            etc                 etc                 etc                etc
ResAdv = advanced_reservoir.tbl

# RESERVOIR MAP. Nominal map with a unique id number specifying each reservoir and extent in the basin. Zero
# values for non-reservoir cells
reservoirs = reservoirs_nominal.map

#**************************************************************************************************
# Define maps and parameters for the calculation of soil erosion according to two soil erosion
# models, i.e. MUSLE, MMF, INCA, SHETRAN, DHSVM and HSPF.
# The section below can be left empty if the sediment module is not used.
#**************************************************************************************************
[SEDIMENT]

# Select soil erosion module. Choose between MUSLE (1), MMF (2), INCA (3), SHETRAN (4), DHSVM (5) and HSPF (6).
SedModel        = 2
# ROCK FRACTION. Scalar map defining the rock fraction (0-1) in the root zone.
RockFrac        = rock_fraction.map

# EXCLUDE CHANNELS FLAG. Flag to indicate if channels should be excluded from the calculation of the detachment by runoff.
exclChannelsFLAG = 1
# UPSTREAM AREA (km2). Threshold for the upstream area from which the channel network is determined. 
upstream_km2    = 10


[MUSLE]
# K_USLE soil erodibility factor. Single value or scalar map with K_USLE coefficients. If left empty, the K-factor is
# determined by the Wischmeier et al. (1978) method. In that case, a sand, clay and organic matter map should be 
# provided in the PEDOTRANSFER section.
K_USLE =
# P_USLE support practice factor. Single value or scalar map with P_USLE coefficients.
P_USLE = 1
# MUSLE FACTORS. Create a lookup table file containing the MUSLE C-factor (cover and management) and
# retardence coefficient for the calculation of overland flow time of concentration. The C-factor and
# retardence coefficient values should correspond to the landuse ID given in the first column.
# Format should be as shown below. The first line should not be in the table file and
# the # marks should be removed:
# ID   #C-factor  #retardence coefficient
# -99  1          2
# 1    value1     value2
# etc  etc        etc
musle_table = musle.tbl


[MMF]
# MMF PARAMETERS. Create a lookup table file containing the MMF parameters: plant height (PH), number
# of stems per unit area (NV), the diameter of the plant stems (D), canopy cover fraction (CC), ground
# cover fraction (GC), no erosion (flag 0 or 1), tillage (flag 0 or 1), fraction to determine ground cover
# from canapy cover, manning, no vegetation (flag 0 or 1). The values for fraction.CC and manning are only
# considered when the value is not equal to zero. The no erosion flag is for those landuse classes where no
# erosion should be calculated (e.g. water or pavement). The MMF parameters should correspond to the landuse
# ID given in the first column. Format should be as shown below. The first line should not be in the table
# file and the # marks should be removed:
# ID   #PH	   #NV	    #D	     #CC      #GC	  #no.erosion	#tillage  #manning  #no.vegetation
# -99  1       2        3        4        5       6             7         8         9
# 1    value1  value2   value3   value4   value5  value6        value7    value8    value9
# etc  etc     etc      etc      etc      etc     etc           etc       etc       etc
MMF_table = mmf.tbl
# HARVEST FLAG. Flag to indicate if the model should take into account changes in land cover due to harvest.
harvestFLAG = 1
# MMF PARAMETERS AFTER HARVEST. Create a lookup table file containing the MMF parameters: sowing date (day of
# the year), and harvest date (day of the year), plant height (PH), number of stems per unit area (NV), the diameter
# of the plant stems (D), canopy cover fraction (CC), ground cover fraction (GC), and tillage (flag 0 or 1). The
# MMF parameters should correspond to the landuse ID given in the first column. Format should be as shown below.
# The first line should not be in the table file and the # marks should be removed:
# ID   #sowing	#harvest    #PH	     #NV      #D        #CC	    #GC     #tillage
# -99  1        2           3        4        5         6       7       8
# 1    value1   value2      value3   value4   value5    value6  value7  value8
# etc  etc      etc         etc      etc      etc       etc     etc     etc
MMF_harvest = mmf_harvest.tbl
# INTENSITY OF THE EROSIVE RAIN (mm h−1).
PrecInt = 30
# CANOPY COVER FROM LAI FLAG. Flag to indicate if the canopy cover should be determined from the LAI. This
# is only possible when the Dynamic Vegetation module is used. When the flag = 0, the canapy cover is determined
# from the MMF table.
CanopyCoverLAIFlag = 1
# DETACHABILITY OF THE SOIL BY RAINDROP IMPACT (g J−1). For clay (K_c), silt (K_z) and sand (K_s) fractions.
K_c = 0.1
K_z = 0.5
K_s = 0.3
# DETACHABILITY OF THE SOIL BY RUNOFF (g mm−1). For clay (DR_c), silt (DR_z) and sand (DR_s) fractions.
DR_c = 1.0
DR_z = 1.6
DR_s = 1.5
# PARTICAL DIAMETER (m). The diameter of the particles for clay, silt and sand.
deltaClay = 2e-6
deltaSilt = 60e-6
deltaSand = 200e-6
# MANNINGS'S ROUGHNESS COEFFICIENT (s m-1/3). For calculation of the bare soil flow velocity.
manning = 0.015
# FLOW DEPTH BARE SOIL (m). For calculation of the bare soil flow velocity.
depthBare = 0.005
# IN FIELD FLOW DEPTH (m). For calculation of the in field flow velocity.
depthInField = 0.1
# FLOW DEPTH TRANSPORT CAPACITY (m). For calculation of the flow velocity used in the transport capacity calculation.
depthTC = 0.25
# SURFACE ROUGHNESS PARAMETER (cm m−1). For calculation of the tilled soil flow velocity.
RFR = 6
# SEDIMENT DENSITY (kg m−3). Typically 2650 kg m−3.
rho_s = 2650
# FLOW DENSITY (kg m-3). Typically 1100 kg m−3 for runoff on hillslopes (Abrahams et al., 2001).
rho = 1100
# FLUID VISCOSITY (kg m−1 s−1). Nominally 0.001 kg m−1 s−1 but taken as 0.0015 to allow for the effects of the sediment in the flow.
eta = 0.0015


[INCA]
# INCA PARAMETERS. Create a lookup table file containing the INCA parameters: vegetation cover (V), ground 
# cover (GC), calibration paramters a4, and no erosion (flag 0 or 1). The INCA parameters should correspond 
# to the landuse ID given in the first column. Format should be as shown below. The first line should not be 
# in the table file and the # marks should be removed:
# ID   #V	   #GC      #a4	     #no.erosion
# -99  1       2        3        4        
# 1    value1  value2   value3   value4   
# etc  etc     etc      etc      etc      
inca_table   = landuse/inca.tbl
# SOIL ERODIBILITY SOIL SPLASH EROSION (kg m-2 s-1). Soil type dependent soil splash erosion potential (kg/m2/s).
E_SP        = 0.005
# SOIL ERODIBILITY FLOW EROSION (kg km-2 s-1). Soil type dependent flow erosion potential (kg/km2/s).
E_FL        = 0.003
# SPLASH DETACHMENT SCALING PARAMETER (s m-1).
c_x1        = 3	
# FLOW EROSION SCALING FACTOR (s m-2).
a1        = 10
# FLOW EROSION DIRECT RUNOFF THRESHOLD (m2 s-1).
a2        = 0
# FLOW EROSION NON-LINEAR COEFFICIENT (-).
a3        = 0.15
# TRANSPORT CAPACITY SCALING FACTOR (kg m-2 km-2). Should be left empty when a4 should be obtained from the INCA table.
a4        = 
# TRANSPORT CAPACITY DIRECT RUNOFF THRESHOLD (m2 s-1).
a5        = 0
# TRANSPORT CAPACITY NON-LINEAR COEFFICIENT (-)
a6        = 0.8


[SHETRAN]
# SHETRAN PARAMETERS. Create a lookup table file containing the SHETRAN parameters: leaf drip diameter (d_l), averege 
# leaf drip distance (X), proportion of the ground shielded by near ground cover (C_g), proportion of the ground 
# shielded by dominant vegetation canopy (C_c), manning (n) and no erosion (flag 0 or 1). The no erosion flag is for 
# those landuse classes where no erosion should be calculated (e.g. water or pavement). The SHETRAN parameters should 
# correspond to the landuse ID given in the first column. Format should be as shown below. The first line should not be 
# in the table file and the # marks should be removed:
# ID   #d_l	   #X       #C_g     #C_c     #n        #no.erosion
# -99  1       2        3        4        5         6
# 1    value1  value2   value3   value4   value5    value6
# etc  etc     etc      etc      etc      etc       etc
shetran_table   = landuse/shetran.tbl
# RAINDROP IMPACT SOIL ERODIBILITY COEFFICIENT (J−1).
k_r = 35
# OVERLAND FLOW SOIL ERODIBILITY COEFFICIENT (kg m-2 s-1).
k_f = 10e-6
# FLOW DENSITY (kg m-3). Typically 1100 kg m−3 for runoff on hillslopes (Abrahams et al., 2001).
rho = 1100
# SEDIMENT DENSITY (kg m−3). Typically 2650 kg m−3.
rho_s = 2650
# PARTICAL DIAMETER (micro m). The diameter of the particles for clay, silt and sand.
deltaClay = 2
deltaSilt = 60
deltaSand = 200
# MEDIAN GRAIN SIZE (micro m). The median grain size of the hillslope material. Only used when pedotransfer flag is set to 0.
D50 = 
# WIDTH DEPTH RATIO (-). The width-depth ratio of the triangular shaped rills.
WD_ratio = 3
# CAPACITY EQUATION. Select the capacity equation: (1) Yalin (1963) and (2) Engelund & Hansen (1967)
capacityEquation = 2


[DHSVM]
# DHSVM PARAMETERS. Create a lookup table file containing the DHSVM parameters: leaf drip diameter (D), averege 
# leaf drip distance (X), proportion of the ground shielded by near ground cover (C_g), proportion of the ground 
# shielded by dominant vegetation canopy (C_c), manning (n), root cohesion, and no erosion (flag 0 or 1). The no 
# erosion flag is for those landuse classes where no erosion should be calculated (e.g. water or pavement). The 
# DHSVM parameters should correspond to the landuse ID given in the first column. Format should be as shown below. 
# The first line should not be in the table file and the # marks should be removed:
# ID   #D	   #X       #C_G     #C_C     #n        #root.cohesion  #no.erosion
# -99  1       2        3        4        5         6               7
# 1    value1  value2   value3   value4   value5    value6          value7
# etc  etc     etc      etc      etc      etc       etc             etc
dhsvm_table   = landuse/dhsvm.tbl
# SOIL CLASS MAP. A map with the soil classes based on the USDA soil texture system.
SoilClass = soil/soil_class.map
# DHSVM SOIL CLASS PARAMETERS. Lookup table containing the DHSVM parameters per soil class: soil cohesion. The DHSVM 
# parameters should correspond to the landuse ID given in the first column. Format should be as shown below. The first
# line should not be in the table file and the # marks should be removed:
# ID   #soil.cohesion
# -99  1       
# 1    value1  
# etc  etc     
dhsvm_cohesion_table = soil/cohesion.tbl
# RAINDROP IMPACT SOIL ERODIBILITY COEFFICIENT (J−1).
k_r = 35
# CRITICAL STREAM POWER (kg m s-3). The critical stream power for the transport capacity equation.
SP_crit = 0.004
# MEDIAN GRAIN SIZE (micro m). The median grain size of the hillslope material. Only used when pedotransfer flag is set to 0.
D50 = 
# WIDTH DEPTH RATIO (-). The width-depth ratio of the triangular shaped rills.
WD_ratio = 3
# MINIMUM WATER DEPTH (m). The minimum water depth for the transport capacity equation.
h_min = 0.001
# FLOW DENSITY (kg m-3). Typically 1100 kg m−3 for runoff on hillslopes (Abrahams et al., 2001).
rho = 1100
# SEDIMENT DENSITY (kg m−3). Typically 2650 kg m−3.
rho_s = 2650
# PARTICAL DIAMETER (micro m). The diameter of the particles for clay, silt and sand.
deltaClay = 2
deltaSilt = 60
deltaSand = 200


[HSPF]
# HSPF FACTORS. Create a lookup table file containing the ground cover (CR), soil scour detachment (KGER), and no
# erosion (flag 0 or 1). The parameters should correspond to the landuse ID given in the first column. Format 
# should be as shown below. The first line should not be in the table file and the # marks should be removed:
# ID   #CR      #KGER   #no.erosion
# -99  1        2       3
# 1    value1   value2  value3  
# etc  etc      etc     etc
hspf_table   = landuse/hspf.tbl
# P_USLE support practice factor. Single value or scalar map with P_USLE coefficients.
P_USLE = 1
# KRER RAINFALL DETACHMENT COEFFICIENT (-). Rainfall detachment coefficient dependent on soil properties. Only used when 
# pedotransfer flag is set to 0. Can be a map or a single value.
KRER = 
# JRER RAINFALL DETACHMENT EXPONENT (-). Rainfall detachment exponent dependent on soil properties.
JRER = 2.25
# KSER WASHOFF DETACHMENT COEFFICIENT (-). Washoff detachment coefficient dependent on soil properties.
KSER = 2.5
# JSER WASHOFF DETACHMENT EXPONENT (-). Washoff detachment exponent dependent on soil properties.
JSER = 2
# KGER SOIL SCOUR DETACHMENT COEFFICIENT (-). Soil scour detachment coefficient dependent on soil properties. 
# Should be left empty when KGER should be obtained from the HSPF table.
KGER = 
# JGER SOIL SCOUR DETACHMENT EXPONENT (-). Soil scour detachment exponent dependent on soil properties.
JGER = 1.5
# AFFIX (-). Fraction by which detached sediment storage decreases each day, as a result of compaction.
AFFIX = 0.05


[SEDIMENT_TRANS]

# INITIAL ROUTED SEDIMENT (ton). Can be a map or a single value.
Sed_init = 0
# TRANSPORT CAPACITY PARAMETERS. TC_beta and TC_gamma are exponents, T_k is a factor.
TC_beta = 1.4
TC_gamma = 1.4
# MANNING CHANNEL FLAG. Flag to indicate if the manning in the channels should be replaced by the value below.
manningChannelFLAG = 1
# UPSTREAM AREA (km2). Threshold for the upstream area from which the channel network is determined. 
upstream_km2 = 10
# MANNING CHANNEL (s m^0.5). Manning value only for the channel cells for calculation of roughness factor for sediment transport.
manningChannel = 0.045
# RESERVOIR TRAPPING EFFICIENCY LOOKUP TABLE. Create a table file containing the reservoir trapping
# efficiency per reservoir in ResId. Only relevant when the reservoir module is used.
# ID   #Trapping efficiency
# -99  1
# 1    0.95
# 6    0.99
TrapEffTab = trapefftab.tbl
# RESERVOIR ORDER TABLE. Select tab-separated txt-file with the order of the reservoirs for routing. Only 
# relevant when the reservoir module is used.
ResOrder = resorder.txt

#***********************************************************************************************
# Define reporting options. SPHY provides output on a daily, monthly and annual basis. Also
# one final map is possible. Below you can modify the reporting for each output. Supply a D for daily
# output, an M for monthly, a Y for yearly, and an F if output at t=end is required. Also a
# combination is possible, where the values should be separated by a comma; e.g. D,M or Y,D or
# Y,M or D,M,Y. If no output is desired, then enter NONE after the =. As second parameter enter
# the desired output file name without extension. Be careful with filename sizes since the output
# is 8 digits before and three digits after the dot. For time-series 'F' is not an option.
#***********************************************************************************************
[REPORTING]

# SELECT COMMA-SEPARATED FILE (CSV) WITH THE REPORTING TABLE
RepTab          = reporting.csv

# FLAGs FOR TIME-SERIES CALCULATION AND REPORTING OF FLUXES IN MM FOR THE UPSTREAM AREA (1=Y, 0=N).
# This is mainly interesting if routing is used as well, to check the mm of water generated from the
# upstream areas.
mm_rep_FLAG	    = 0
QTOT_mm_FLAG    = 0
QSNOW_mm_FLAG   = 0
QROOTR_mm_FLAG  = 0
QROOTD_mm_FLAG  = 0
QRAIN_mm_FLAG   = 0
GMelt_mm_FLAG   = 0
QGLAC_mm_FLAG   = 0
QBASE_mm_FLAG   = 0
Prec_mm_FLAG    = 0
ETa_mm_FLAG     = 0
Seep_mm_FLAG    = 0

wbal_TSS_FLAG   = 0

############## ONLY FOR LAKE AND/OR RESERVOIR MODULE ##########################################
# FLAG TO REPORT LAKE WATER BALANCE (inflow, outlfow, and storage) (1=Y, 0=N)
Lake_wbal       = 0
# FLAG TO REPORT RESERVOIR WATER BALANCE (inflow, outlfow, and storage) (1=Y, 0=N)
Res_wbal        = 0

RepSnow_FLAG    = 0
RepRootR_FLAG   = 0
RepRootD_FLAG   = 0
RepRain_FLAG    = 0
RepGlac_FLAG    = 0
RepBase_FLAG    = 0
